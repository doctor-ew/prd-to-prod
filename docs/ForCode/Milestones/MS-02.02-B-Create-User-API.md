# Milestone MS-02.02-B: Create API Routes for User Actions

## Framework: P-R-O-M-P-T

### Persona
You are a backend developer creating secure and efficient serverless API routes. Your primary responsibility is to create endpoints that allow the frontend to interact with the database for creating and updating user data.

### Request
Create a new API route at `/api/user` that can handle `GET` and `POST` requests to manage user profiles and favorites. This involves reading a `userId` from the client, finding or creating a user profile in the database, and updating their preferences (like language) or their list of favorite venues.

### Objective
To build a robust API endpoint that serves as the backend for all user personalization features. The endpoint must handle:
1.  Fetching an existing user profile.
2.  Creating a new user profile if one doesn't exist.
3.  Updating a user's preferred language.
4.  Adding or removing a venue from a user's favorites.

### Method
1.  Create a new `route.ts` file under `src/app/api/user`.
2.  Implement the `GET` handler to find a user by their ID.
3.  Implement the `POST` handler that will use a `find-or-create` pattern (`upsert` in Prisma) for the user profile.
4.  The `POST` handler will read the request body to determine what action to take (e.g., `updateLanguage`, `toggleFavorite`).
5.  All database interactions will use the Prisma Client.

### Product
A functional API route at `/api/user` that allows the frontend to read and write user preference data to the database.

---

## Learning Outcomes

-   **Outcome 1**: Learn how to create a Next.js API route that handles multiple HTTP methods (`GET`, `POST`).
-   **Outcome 2**: Understand how to read query parameters and request bodies to create flexible, multi-purpose API endpoints.
-   **Outcome 3**: Implement a common "find-or-create" logic (`upsert`) for user profiles, a foundational pattern for applications with implicit user sessions.

---

## Context from Source Docs

**Business Rationale (PRD)**: Directly supports the "Personalized User Experience" by providing the mechanism to save user preferences and favorites.
**WBS Alignment**: Phase 3 development. This is the server-side component of the user features.
**Dependencies**: MS-02.02-A (Update Schema for User Features).
**Files to Create/Modify**:
-   `src/app/api/user/route.ts` (new file)
-   `src/lib/user.ts` (new file for helper functions)

**Acceptance Criteria**:
-   `GET /api/user?userId=<id>` returns the user's profile data or `null`.
-   `POST /api/user` with a `userId` and `language` in the body correctly creates or updates the user's language preference.
-   `POST /api/user` with a `userId` and `venueId` in the body correctly adds or removes that venue from the user's favorites list.
-   The API responds with the updated user profile data after a `POST` request.

---

## Guardrails

-   **Security**: The `userId` will be a client-generated ID. While not highly secure, it's sufficient for this MVP. All input (`language`, `venueId`) **must** be validated on the server.
-   **Data Handling**: Use Prisma's `upsert` for creating profiles and a transaction for toggling favorites to ensure atomic operations.
-   **Code Quality**: Abstract the core database logic into helper functions in `src/lib/user.ts` to keep the API route handler clean.

---

## Implementation Checklist

-   [ ] **Task 1**: Create a library file for user database logic.
    -   **Action**: Create a new file at `src/lib/user.ts`. This abstracts the Prisma calls.
    ```ts
    import { PrismaClient } from '@prisma/client';
    const prisma = new PrismaClient();

    export async function getOrCreateUserProfile(userId: string) {
      return prisma.userProfile.upsert({
        where: { id: userId },
        update: {},
        create: { id: userId },
        include: { favorites: true },
      });
    }

    export async function updateUserLanguage(userId: string, language: string) {
      return prisma.userProfile.update({
        where: { id: userId },
        data: { language },
        include: { favorites: true },
      });
    }

    export async function toggleFavoriteVenue(userId: string, venueId: string) {
      // Check if the favorite already exists
      const existingFavorite = await prisma.userFavorite.findUnique({
        where: { profileId_venueId: { profileId: userId, venueId } },
      });

      if (existingFavorite) {
        // Remove it
        await prisma.userFavorite.delete({ where: { id: existingFavorite.id } });
      } else {
        // Add it
        await prisma.userFavorite.create({ data: { profileId: userId, venueId } });
      }
      return getOrCreateUserProfile(userId);
    }
    ```
    -   **Acceptance**: The `lib/user.ts` file is created.
-   [ ] **Task 2**: Create the API route handlers.
    -   **Action**: Create a new file at `src/app/api/user/route.ts`.
    ```ts
    import { NextResponse } from 'next/server';
    import { getOrCreateUserProfile, updateUserLanguage, toggleFavoriteVenue } from '@/lib/user';

    export async function GET(request: Request) {
      const { searchParams } = new URL(request.url);
      const userId = searchParams.get('userId');

      if (!userId) {
        return NextResponse.json({ error: 'userId is required' }, { status: 400 });
      }
      const userProfile = await getOrCreateUserProfile(userId);
      return NextResponse.json(userProfile);
    }

    export async function POST(request: Request) {
      const body = await request.json();
      const { userId, language, venueId } = body;

      if (!userId) {
        return NextResponse.json({ error: 'userId is required' }, { status: 400 });
      }

      // Ensure user exists before any action
      await getOrCreateUserProfile(userId);

      let updatedProfile;
      if (language) {
        updatedProfile = await updateUserLanguage(userId, language);
      } else if (venueId) {
        updatedProfile = await toggleFavoriteVenue(userId, venueId);
      } else {
        return NextResponse.json({ error: 'Either language or venueId is required' }, { status: 400 });
      }

      return NextResponse.json(updatedProfile);
    }
    ```
    -   **Acceptance**: The `api/user/route.ts` file is created with `GET` and `POST` handlers.

---

## Testing Requirements

-   [ ] **Integration Tests**: Write tests for the `/api/user` endpoint.
    -   Test `GET` with a `userId` and verify it returns a profile.
    -   Test `POST` to update a language and verify the result.
    -   Test `POST` to add a favorite, verify it's added. Test it again and verify it's removed.
-   [ ] **Manual Verification**:
    1.  Use a tool like Postman, Insomnia, or `curl` to test the endpoints.
    2.  **Test GET**: Make a `GET` request to `http://localhost:3000/api/user?userId=test-user-123`. **Confirm** it returns a new user profile with default language 'en' and empty favorites.
    3.  **Test POST (Language)**: Make a `POST` request to `http://localhost:3000/api/user` with body `{"userId": "test-user-123", "language": "es"}`. **Confirm** the returned profile shows `"language": "es"`.
    4.  **Test POST (Favorite)**: Make a `POST` request with body `{"userId": "test-user-123", "venueId": "ID_OF_MBS_STADIUM"}` (you can get this ID from Prisma Studio). **Confirm** the returned profile's `favorites` array contains the venue.
    5.  **Test POST (Un-Favorite)**: Send the same request again. **Confirm** the `favorites` array is now empty.

---

## Success Criteria

This milestone is complete when:
1.  The `/api/user` endpoint is fully functional for getting, creating, and updating user profiles and favorites.
2.  The API logic is cleanly separated into a library file.
3.  The endpoint handles input correctly and returns the updated user state.
4.  All acceptance criteria are met and manual/integration tests pass.
