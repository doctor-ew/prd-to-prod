# Milestone MS-01.03-B: MARTA Train API with Codespaces Proxy

## Framework: F-O-C-U-S

### Frame
The MARTA Train API provides essential real-time data, but it runs on a non-standard port (18096). Our primary development environment, GitHub Codespaces, blocks outbound connections to non-standard ports for security reasons. This means a direct API call will fail in Codespaces. We must implement an environment-aware solution that automatically uses a proxy when in Codespaces but connects directly in production (Vercel) and local environments.

### Objective
To successfully integrate the MARTA Train API by creating a data fetching function that:
1.  Detects if it is running inside GitHub Codespaces.
2.  Conditionally builds the API URL, prepending a proxy URL only when in Codespaces.
3.  Fetches, parses, and transforms the train data into the standardized `TransitVehicle` format.
4.  Handles failures gracefully and returns an empty array on error.

### Constraints
-   **Technology**: Must use `process.env` variables for environment detection. The proxy `https://api.allorigins.win/raw?url=` is approved for the Codespaces environment **only**.
-   **Performance**: The API call must time out after 10 seconds. The additional latency from the proxy in Codespaces is acceptable.
-   **Security**: The `MARTA_TRAIN_API_KEY` must only be used on the server-side and must not be exposed to the client. The key will be part of the URL sent to the proxy, which is an accepted risk for the development environment.

### Users
-   **Primary**: Developers in GitHub Codespaces who need the app to work seamlessly without manual workarounds.
-   **Secondary**: End-users of the application who will see the real-time train locations on the map.

### Steps
1.  Create a utility function to detect the Codespaces environment.
2.  Create a function to fetch and parse train data, including the conditional proxy logic.
3.  Integrate this new function into the main `/api/transit` API route.
4.  Ensure the API key is loaded correctly from environment variables.

---

## Learning Outcomes

-   **Outcome 1**: Learn how to write environment-aware code that behaves differently based on the context (development vs. production).
-   **Outcome 2**: Understand a practical solution (CORS proxy) for overcoming network restrictions in cloud-based development environments.
-   **Outcome 3**: Gain experience with handling sensitive API keys in serverless functions and the security considerations of using third-party proxies.

---

## Context from Source Docs

**Business Rationale (PRD)**: To provide a complete, real-time transit picture for users. Missing train data would render the navigation feature incomplete and unreliable.
**WBS Alignment**: Phase 3 -> Task 3.6.2, 3.6.3, 3.6.4. This milestone covers the core logic for Train API integration and the Codespaces-specific proxy.
**Dependencies**: MS-01.03-A (Bus API Integration).
**Files to Create/Modify**:
-   `src/lib/codespaces.ts` (new file)
-   `src/lib/marta.ts`
-   `src/app/api/transit/route.ts`
-   `.env.local` (user must add `MARTA_TRAIN_API_KEY`)

**Acceptance Criteria**:
-   The `/api/transit` route returns train data correctly in both local and Codespaces environments.
-   In Codespaces, console logs show that the proxy is being used.
-   In a local environment, console logs show a direct connection is being used.
-   The returned train data is correctly transformed into the `TransitVehicle` format.

---

## Guardrails

-   **Environment-Specific Constraints**: The proxy solution **must only** be active in the Codespaces environment. Production deployments on Vercel **must** use a direct connection.
-   **Security**: The `MARTA_TRAIN_API_KEY` **must** be loaded from environment variables and never hardcoded. Use `encodeURIComponent` when wrapping the target URL for the proxy.
-   **Data Handling**: The API response is a JSON array. Deduplicate trains by `TRAIN_ID` as the API may return multiple entries for the same train.

---

## Implementation Checklist

-   [ ] **Task 1**: Create the Codespaces detection utility.
    -   **Action**: Create a new file at `src/lib/codespaces.ts`. Add the following code.
    ```ts
    export function isRunningInCodespaces(): boolean {
      return process.env.CODESPACES === 'true' ||
             !!process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN;
    }
    ```
    -   **Acceptance**: The file is created and the function is available for import.
-   [ ] **Task 2**: Add the train data fetching logic to `src/lib/marta.ts`.
    -   **Action**: Open `src/lib/marta.ts` and add the new function `fetchTrainData`.
    ```ts
    // Add this import at the top
    import { isRunningInCodespaces } from './codespaces';

    // ... existing fetchBusData function ...

    const MARTA_TRAIN_API_URL = `https://developerservices.itsmarta.com:18096/itsmarta/railrealtimearrivals/developerservices/traindata?apiKey=${process.env.MARTA_TRAIN_API_KEY}`;

    export async function fetchTrainData(): Promise<TransitVehicle[]> {
      let url = MARTA_TRAIN_API_URL;
      if (isRunningInCodespaces()) {
        console.log("Codespaces environment detected. Using proxy for MARTA Train API.");
        url = `https://api.allorigins.win/raw?url=${encodeURIComponent(MARTA_TRAIN_API_URL)}`;
      } else {
        console.log("Using direct connection for MARTA Train API.");
      }

      try {
        const response = await fetch(url, { next: { revalidate: 30 } });
        if (!response.ok) {
          console.error('MARTA Train API request failed:', response.statusText);
          return [];
        }
        const data = await response.json();
        
        // Deduplicate trains by TRAIN_ID
        const uniqueTrains = new Map();
        data.forEach((train: any) => {
          uniqueTrains.set(train.TRAIN_ID, train);
        });

        const trains: TransitVehicle[] = Array.from(uniqueTrains.values()).map((train: any) => ({
          id: train.TRAIN_ID,
          lat: parseFloat(train.LATITUDE),
          lon: parseFloat(train.LONGITUDE),
          route: train.LINE,
          type: 'train',
        }));
        return trains;
      } catch (error) {
        console.error('Error fetching or parsing MARTA train data:', error);
        return [];
      }
    }
    ```
    -   **Acceptance**: The `fetchTrainData` function is added and correctly implements the conditional proxy logic.
-   [ ] **Task 3**: Update the `/api/transit` route to include train data.
    -   **Action**: Open `src/app/api/transit/route.ts` and modify the `GET` handler.
    ```ts
    import { NextResponse } from 'next/server';
    import { fetchBusData, fetchTrainData } from '@/lib/marta';

    export async function GET() {
      try {
        // Fetch both in parallel for efficiency
        const [buses, trains] = await Promise.all([
          fetchBusData(),
          fetchTrainData(),
        ]);
        
        return NextResponse.json({ buses, trains });
      } catch (error) {
        console.error('Error in /api/transit:', error);
        return NextResponse.json({ error: 'Failed to fetch transit data' }, { status: 500 });
      }
    }
    ```
    -   **Acceptance**: The API route now calls both `fetchBusData` and `fetchTrainData` in parallel and returns both datasets in the final JSON response.

---

## Testing Requirements

-   [ ] **Manual Verification**:
    1.  Add your MARTA Train API key to your `.env.local` file: `MARTA_TRAIN_API_KEY=YOUR_KEY_HERE`.
    2.  **Test in Codespaces**:
        -   Run `pnpm dev`.
        -   Check the terminal logs for the message "Codespaces environment detected. Using proxy...".
        -   Open `http://localhost:3000/api/transit`.
        -   **Confirm**: The `trains` array in the JSON response contains data.
    3.  **Test Locally (if possible)**:
        -   Clone the repository to your local machine and run `pnpm install` and `pnpm dev`.
        -   Check the terminal logs for the message "Using direct connection...".
        -   Open `http://localhost:3000/api/transit`.
        -   **Confirm**: The `trains` array in the JSON response contains data.

---

## Success Criteria

This milestone is complete when:
1.  The `/api/transit` endpoint successfully returns both bus and train data.
2.  The application automatically uses the proxy for train data when running in GitHub Codespaces and a direct connection otherwise.
3.  Console logs clearly indicate which connection method is being used.
4.  The implementation is resilient to API failures and adheres to all guardrails.
5.  All acceptance criteria are met.
