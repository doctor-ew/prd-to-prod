# Milestone MS-01.03-A: MARTA Bus API Integration

## Framework: P-R-O-M-P-T

### Persona
You are a backend developer responsible for creating reliable, serverless API routes. Your focus is on data fetching, parsing, and transformation. You write clean, modular, and testable server-side code.

### Request
Implement the server-side logic to fetch real-time bus data from the MARTA GTFS-RT API. This involves making an HTTP request to a Protobuf endpoint, parsing the binary data, and transforming it into a clean, JSON-serializable format for the frontend.

### Objective
Create a function within a new `/api/transit` Next.js API route that fetches and processes data from the MARTA Bus API. This function must be resilient to errors and return a standardized data structure.

### Method
1.  Use the native `fetch` API to make a GET request to the MARTA Bus API endpoint.
2.  Read the response body as an `ArrayBuffer`.
3.  Use the `gtfs-realtime-bindings` library to parse the Protobuf buffer into a JavaScript object.
4.  Map the parsed data to a simplified `TransitVehicle` type, extracting only the necessary fields (ID, latitude, longitude, route).
5.  Wrap the entire logic in a `try...catch` block to handle network failures or parsing errors gracefully.

### Product
A server-side function that returns a promise resolving to an array of bus objects, like `[{ id: "bus1", lat: 33.7, lon: -84.3, route: "1" }]`, or an empty array in case of an error.

---

## Learning Outcomes

-   **Outcome 1**: Learn how to consume a non-JSON API endpoint (Protobuf) in a Node.js environment using Next.js API Routes.
-   **Outcome 2**: Understand data transformation and sanitization by mapping a complex, nested API response to a simple, clean data structure.
-   **Outcome 3**: Gain experience in building resilient serverless functions that can handle external service failures.

---

## Context from Source Docs

**Business Rationale (PRD)**: To provide real-time navigation and transportation information. Bus data is a critical component of the city's transit system, and users expect to see live vehicle locations.
**WBS Alignment**: Phase 3 -> Task 3.6.1 (Implement MARTA Bus API (GTFS-RT) integration).
**Dependencies**: MS-01.01 (Project Setup).
**Files to Create/Modify**:
-   `package.json`
-   `src/lib/marta.ts` (new file)
-   `src/app/api/transit/route.ts` (new file)
-   `src/types/index.ts` (new file or existing)

**Acceptance Criteria**:
-   The `/api/transit` API route is created and accessible.
-   When called, the route successfully fetches the Protobuf data from the MARTA Bus API.
-   The Protobuf data is parsed and transformed into a JSON array of bus objects.
-   The API route returns a JSON response containing a `buses` array with the transformed data.

---

## Guardrails

-   **Performance**: The external API call **must** have a timeout of 10 seconds.
-   **Security**: This API does not require a key, so no secret management is needed for this specific task.
-   **Data Handling**: All data from the external API **must** be validated or safely parsed. If the `gtfs-realtime-bindings` library throws an error, the function **must** catch it and return an empty array.
-   **Code Quality**: The data fetching and parsing logic **must** be in its own function in `src/lib/marta.ts` to keep the API route file clean and reusable.

---

## Implementation Checklist

-   [ ] **Task 1**: Install the GTFS-RT parsing library.
    -   **Action**: Run this exact command in the terminal: `pnpm add gtfs-realtime-bindings`
    -   **Acceptance**: The dependency is added to `package.json`.
-   [ ] **Task 2**: Define the shared data type.
    -   **Action**: Create a new file `src/types/index.ts` and define a shared type for transit vehicles.
    ```ts
    export interface TransitVehicle {
      id: string;
      lat: number;
      lon: number;
      route: string;
      type: 'bus' | 'train';
    }
    ```
    -   **Acceptance**: The `types/index.ts` file is created with the `TransitVehicle` interface.
-   [ ] **Task 3**: Create the server-side utility to fetch and parse bus data.
    -   **Action**: Create a new file `src/lib/marta.ts`. Add the following code.
    ```ts
    import GtfsRealtimeBindings from 'gtfs-realtime-bindings';
    import { TransitVehicle } from '@/types';

    const MARTA_BUS_API_URL = 'https://gtfs-rt.itsmarta.com/TMGTFSRealTimeWebService/vehicle/vehiclepositions.pb';

    export async function fetchBusData(): Promise<TransitVehicle[]> {
      try {
        const response = await fetch(MARTA_BUS_API_URL, {
          next: { revalidate: 30 }, // Cache for 30 seconds
        });
        if (!response.ok) {
          console.error('MARTA Bus API request failed:', response.statusText);
          return [];
        }
        const buffer = await response.arrayBuffer();
        const feed = GtfsRealtimeBindings.transit_realtime.FeedMessage.decode(new Uint8Array(buffer));
        
        const buses: TransitVehicle[] = feed.entity.map((entity) => ({
          id: entity.id,
          lat: entity.vehicle.position.latitude,
          lon: entity.vehicle.position.longitude,
          route: entity.vehicle.trip.routeId,
          type: 'bus',
        }));
        return buses;
      } catch (error) {
        console.error('Error fetching or parsing MARTA bus data:', error);
        return [];
      }
    }
    ```
    -   **Acceptance**: The `lib/marta.ts` file is created, and the function correctly fetches and transforms the data.
-   [ ] **Task 4**: Create the `/api/transit` API route.
    -   **Action**: Create a new file at `src/app/api/transit/route.ts`. Add the following code.
    ```ts
    import { NextResponse } from 'next/server';
    import { fetchBusData } from '@/lib/marta';

    export async function GET() {
      try {
        const buses = await fetchBusData();
        // Placeholder for train data in the next milestone
        const trains = []; 
        
        return NextResponse.json({ buses, trains });
      } catch (error) {
        console.error('Error in /api/transit:', error);
        return NextResponse.json({ error: 'Failed to fetch transit data' }, { status: 500 });
      }
    }
    ```
    -   **Acceptance**: Accessing `GET /api/transit` returns a `200 OK` status and a JSON payload like `{ "buses": [...], "trains": [] }`.

---

## Testing Requirements

-   [ ] **Unit Test**: Write a unit test for the `fetchBusData` function. Use a mocking library like `jest` or `vitest` with `msw` to mock the `fetch` call and provide a sample Protobuf response to verify the parsing and transformation logic.
-   [ ] **Integration Test**: Write a test for the `/api/transit` endpoint that verifies it returns a 200 status code and the expected JSON structure (`{ buses: [], trains: [] }`).
-   [ ] **Manual Verification**:
    1.  Run `pnpm dev`.
    2.  Open `http://localhost:3000/api/transit` in your browser.
    3.  **Confirm**: A JSON response is returned.
    4.  **Confirm**: The `buses` array in the JSON contains a list of bus objects, each with `id`, `lat`, `lon`, `route`, and `type`.

---

## Success Criteria

This milestone is complete when:
1.  The `/api/transit` endpoint is live and returns a well-formed JSON response containing real-time bus data.
2.  The implementation is resilient to API failures and parsing errors.
3.  The data fetching logic is properly modularized in `src/lib/marta.ts`.
4.  All acceptance criteria are met and manual verification passes.
